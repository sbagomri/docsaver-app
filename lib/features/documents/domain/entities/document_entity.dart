/// Document entity for domain layer
class DocumentEntity {
  final int? id;
  final String title;
  final String category;
  final String filePath;
  final String? thumbnailPath;
  final int fileSizeBytes;
  final String mimeType;
  final DateTime createdAt;
  final DateTime modifiedAt;
  final List<String> tags;
  final bool isFavorite;
  final String? extractedText;
  final bool isOcrProcessed;
  final String? cloudStorageUrl;
  final bool isSynced;
  final DateTime? lastSyncedAt;

  const DocumentEntity({
    this.id,
    required this.title,
    required this.category,
    required this.filePath,
    this.thumbnailPath,
    required this.fileSizeBytes,
    required this.mimeType,
    required this.createdAt,
    required this.modifiedAt,
    this.tags = const [],
    this.isFavorite = false,
    this.extractedText,
    this.isOcrProcessed = false,
    this.cloudStorageUrl,
    this.isSynced = false,
    this.lastSyncedAt,
  });

  DocumentEntity copyWith({
    int? id,
    String? title,
    String? category,
    String? filePath,
    String? thumbnailPath,
    int? fileSizeBytes,
    String? mimeType,
    DateTime? createdAt,
    DateTime? modifiedAt,
    List<String>? tags,
    bool? isFavorite,
    String? extractedText,
    bool? isOcrProcessed,
    String? cloudStorageUrl,
    bool? isSynced,
    DateTime? lastSyncedAt,
  }) {
    return DocumentEntity(
      id: id ?? this.id,
      title: title ?? this.title,
      category: category ?? this.category,
      filePath: filePath ?? this.filePath,
      thumbnailPath: thumbnailPath ?? this.thumbnailPath,
      fileSizeBytes: fileSizeBytes ?? this.fileSizeBytes,
      mimeType: mimeType ?? this.mimeType,
      createdAt: createdAt ?? this.createdAt,
      modifiedAt: modifiedAt ?? this.modifiedAt,
      tags: tags ?? this.tags,
      isFavorite: isFavorite ?? this.isFavorite,
      extractedText: extractedText ?? this.extractedText,
      isOcrProcessed: isOcrProcessed ?? this.isOcrProcessed,
      cloudStorageUrl: cloudStorageUrl ?? this.cloudStorageUrl,
      isSynced: isSynced ?? this.isSynced,
      lastSyncedAt: lastSyncedAt ?? this.lastSyncedAt,
    );
  }

  String get formattedSize {
    if (fileSizeBytes < 1024) return '$fileSizeBytes B';
    if (fileSizeBytes < 1024 * 1024) {
      return '${(fileSizeBytes / 1024).toStringAsFixed(2)} KB';
    }
    return '${(fileSizeBytes / (1024 * 1024)).toStringAsFixed(2)} MB';
  }

  bool get hasExpired {
    // This would check extracted expiration date
    // TODO: Implement based on extracted_data
    return false;
  }
}

/// Category entity
class CategoryEntity {
  final int? id;
  final String name;
  final String icon;
  final int sortOrder;
  final bool isSystem;
  final DateTime createdAt;

  const CategoryEntity({
    this.id,
    required this.name,
    required this.icon,
    required this.sortOrder,
    this.isSystem = false,
    required this.createdAt,
  });

  CategoryEntity copyWith({
    int? id,
    String? name,
    String? icon,
    int? sortOrder,
    bool? isSystem,
    DateTime? createdAt,
  }) {
    return CategoryEntity(
      id: id ?? this.id,
      name: name ?? this.name,
      icon: icon ?? this.icon,
      sortOrder: sortOrder ?? this.sortOrder,
      isSystem: isSystem ?? this.isSystem,
      createdAt: createdAt ?? this.createdAt,
    );
  }
}

/// Reminder entity
class ReminderEntity {
  final int? id;
  final int documentId;
  final String title;
  final String? description;
  final DateTime reminderDate;
  final bool isAutoGenerated;
  final bool isCompleted;
  final int? notificationId;
  final DateTime createdAt;

  const ReminderEntity({
    this.id,
    required this.documentId,
    required this.title,
    this.description,
    required this.reminderDate,
    this.isAutoGenerated = false,
    this.isCompleted = false,
    this.notificationId,
    required this.createdAt,
  });

  ReminderEntity copyWith({
    int? id,
    int? documentId,
    String? title,
    String? description,
    DateTime? reminderDate,
    bool? isAutoGenerated,
    bool? isCompleted,
    int? notificationId,
    DateTime? createdAt,
  }) {
    return ReminderEntity(
      id: id ?? this.id,
      documentId: documentId ?? this.documentId,
      title: title ?? this.title,
      description: description ?? this.description,
      reminderDate: reminderDate ?? this.reminderDate,
      isAutoGenerated: isAutoGenerated ?? this.isAutoGenerated,
      isCompleted: isCompleted ?? this.isCompleted,
      notificationId: notificationId ?? this.notificationId,
      createdAt: createdAt ?? this.createdAt,
    );
  }

  bool get isPending => !isCompleted && reminderDate.isAfter(DateTime.now());
  bool get isOverdue => !isCompleted && reminderDate.isBefore(DateTime.now());
}

/// Extracted data entity
class ExtractedDataEntity {
  final int? id;
  final int documentId;
  final String dataType;
  final String value;
  final DateTime? dateValue;
  final double confidence;
  final DateTime extractedAt;

  const ExtractedDataEntity({
    this.id,
    required this.documentId,
    required this.dataType,
    required this.value,
    this.dateValue,
    this.confidence = 0.0,
    required this.extractedAt,
  });

  ExtractedDataEntity copyWith({
    int? id,
    int? documentId,
    String? dataType,
    String? value,
    DateTime? dateValue,
    double? confidence,
    DateTime? extractedAt,
  }) {
    return ExtractedDataEntity(
      id: id ?? this.id,
      documentId: documentId ?? this.documentId,
      dataType: dataType ?? this.dataType,
      value: value ?? this.value,
      dateValue: dateValue ?? this.dateValue,
      confidence: confidence ?? this.confidence,
      extractedAt: extractedAt ?? this.extractedAt,
    );
  }

  bool get isHighConfidence => confidence >= 0.8;
  bool get isDateType => dataType.contains('date');
}

